# -*- coding: utf-8 -*-
"""Bankrupcy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BOIkgJXAQxpulOddugwuKKAA8jibG4Hk
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

file_path = "/content/Financial Distress.csv"
df = pd.read_csv(file_path)

df['Financial Distress'] = (df['Financial Distress'] > -0.50).astype(int)

X = df.drop(['Company', 'Time', 'Financial Distress'], axis=1)
y = df['Financial Distress']

accuracies = []

for i in range(10):
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=i)
    knn_classifier = KNeighborsClassifier(n_neighbors=5)
    knn_classifier.fit(X_train, y_train)
    y_pred = knn_classifier.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    accuracies.append(accuracy)

    print(f"{accuracy*100:.2f}")
mean_accuracy = sum(accuracies) / len(accuracies)
print("\nMean Accuracy:", mean_accuracy)

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import accuracy_score

file_path = "/content/Financial Distress.csv"
df = pd.read_csv(file_path)

# Convert 'Financial Distress' to binary classification
df['Financial Distress'] = (df['Financial Distress'] > -0.50).astype(int)

X = df.drop(['Company', 'Time', 'Financial Distress'], axis=1)
y = df['Financial Distress']

accuracies = []

for i in range(10):
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=i)
    nb_classifier = GaussianNB()
    nb_classifier.fit(X_train, y_train)
    y_pred = nb_classifier.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    accuracies.append(accuracy)

    print(f"Accuracy for iteration {i+1}: {accuracy:.4f}")
mean_accuracy = sum(accuracies) / len(accuracies)
print("\nMean Accuracy:", mean_accuracy)

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPClassifier
from sklearn.metrics import accuracy_score

file_path = "/content/Financial Distress.csv"
df = pd.read_csv(file_path)

# Convert 'Financial Distress' to binary classification
df['Financial Distress'] = (df['Financial Distress'] > -0.50).astype(int)

X = df.drop(['Company', 'Time', 'Financial Distress'], axis=1)
y = df['Financial Distress']

accuracies = []

for i in range(10):
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=i)
    ann_classifier = MLPClassifier(hidden_layer_sizes=(100,), max_iter=1000, random_state=42)
    ann_classifier.fit(X_train, y_train)
    y_pred = ann_classifier.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    accuracies.append(accuracy)

    print(f"{accuracy*100:.2f}")
mean_accuracy = sum(accuracies) / len(accuracies)
print("\nMean Accuracy:", mean_accuracy)

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
import numpy as np

file_path = "/content/Financial Distress.csv"
df = pd.read_csv(file_path)

# Convert 'Financial Distress' to binary classification
df['Financial Distress'] = (df['Financial Distress'] > -0.50).astype(int)

# Introduce noise in the target variable
np.random.seed(42)  # Set seed for reproducibility
noise_ratio = 0.1  # Adjust the noise ratio as needed
df['Financial Distress'] = np.where(np.random.rand(len(df)) < noise_ratio, 1 - df['Financial Distress'], df['Financial Distress'])

X = df.drop(['Company', 'Time', 'Financial Distress'], axis=1)
y = df['Financial Distress']

accuracies = []

for i in range(10):
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=i)

    # Logistic Regression classifier
    logreg_classifier = LogisticRegression()
    logreg_classifier.fit(X_train, y_train)

    # Predictions
    y_pred = logreg_classifier.predict(X_test)

    # Accuracy
    accuracy = accuracy_score(y_test, y_pred)
    accuracies.append(accuracy)

    print(f"Accuracy for iteration {i+1}: {accuracy:.4f}")

# Print mean accuracy and standard deviation
mean_accuracy = sum(accuracies) / len(accuracies)
std_accuracy = np.std(accuracies)
print("\nMean Accuracy:", mean_accuracy)
print("Standard Deviation of Accuracies:", std_accuracy)

# Confusion Matrix
confusion_mat = confusion_matrix(y_test, y_pred)
print("\nConfusion Matrix:\n", confusion_mat)

# Classification Report
class_report = classification_report(y_test, y_pred)
print("\nClassification Report:\n", class_report)

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
import numpy as np

file_path = "/content/Financial Distress.csv"
df = pd.read_csv(file_path)

# Convert 'Financial Distress' to binary classification
df['Financial Distress'] = (df['Financial Distress'] > -0.50).astype(int)

# Introduce noise in the target variable
np.random.seed(42)  # Set seed for reproducibility
noise_ratio = 0.1  # Adjust the noise ratio as needed
df['Financial Distress'] = np.where(np.random.rand(len(df)) < noise_ratio, 1 - df['Financial Distress'], df['Financial Distress'])

X = df.drop(['Company', 'Time', 'Financial Distress'], axis=1)
y = df['Financial Distress']

accuracies = []

for i in range(10):
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=i)

    # SVM classifier
    svm_classifier = SVC()
    svm_classifier.fit(X_train, y_train)

    # Predictions
    y_pred = svm_classifier.predict(X_test)

    # Accuracy
    accuracy = accuracy_score(y_test, y_pred)
    accuracies.append(accuracy)

    print(f"{accuracy*100:.2f}")

# Print mean accuracy and standard deviation
mean_accuracy = sum(accuracies) / len(accuracies)
std_accuracy = np.std(accuracies)
print("\nMean Accuracy:", mean_accuracy)
print("Standard Deviation of Accuracies:", std_accuracy)

# Confusion Matrix
confusion_mat = confusion_matrix(y_test, y_pred)
print("\nConfusion Matrix:\n", confusion_mat)

# Classification Report
class_report = classification_report(y_test, y_pred)
print("\nClassification Report:\n", class_report)

import pandas as pd
from sklearn.model_selection import train_test_split
from xgboost import XGBClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
import numpy as np

file_path = "/content/Financial Distress.csv"
df = pd.read_csv(file_path)

# Convert 'Financial Distress' to binary classification
df['Financial Distress'] = (df['Financial Distress'] > -0.50).astype(int)

# Introduce noise in the target variable
np.random.seed(42)  # Set seed for reproducibility
noise_ratio = 0.1  # Adjust the noise ratio as needed
df['Financial Distress'] = np.where(np.random.rand(len(df)) < noise_ratio, 1 - df['Financial Distress'], df['Financial Distress'])

X = df.drop(['Company', 'Time', 'Financial Distress'], axis=1)
y = df['Financial Distress']

accuracies = []

for i in range(10):
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=i)

    # XGBoost classifier
    xgb_classifier = XGBClassifier()
    xgb_classifier.fit(X_train, y_train)

    # Predictions
    y_pred = xgb_classifier.predict(X_test)

    # Accuracy
    accuracy = accuracy_score(y_test, y_pred)
    accuracies.append(accuracy)

    print(f"{accuracy*100:.2f}")

# Print mean accuracy and standard deviation
mean_accuracy = sum(accuracies) / len(accuracies)
std_accuracy = np.std(accuracies)
print("\nMean Accuracy:", mean_accuracy)
print("Standard Deviation of Accuracies:", std_accuracy)

# Confusion Matrix
confusion_mat = confusion_matrix(y_test, y_pred)
print("\nConfusion Matrix:\n", confusion_mat)

# Classification Report
class_report = classification_report(y_test, y_pred)
print("\nClassification Report:\n", class_report)